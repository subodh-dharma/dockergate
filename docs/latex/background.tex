\section{Background}
\label{sec:background}
The following section describes the background for the paper and our motivation towards proposing DockerGate
\subsection{Docker}
Docker~\cite{docker} is an application that helps software developers in deploying their applications across a wide variety of host operating systems without needing to manually configure the dependencies on each individual platform. All system dependencies like required packages and configuration is stored with the actual application in a read-only file called a Docker Image~\cite{dockerimages}. This allows the developers to configure the application once and deploy it multiple times on variety of platforms without worrying about the platform-specific issues. Whenever the application has to be deployed, the Docker Image is instantiated as a Docker Container~\cite{dockerimages}, that is spawned on the host operating system by a Docker Daemon, that runs on the host itself. Other advantages of running an application in a Docker container are its performance and the process isolation.

Docker containers are considered lightweight. This can allow one host to spawn several containers at a time. Every container behaves as an independent virtual machine in itself, complete with its own file system. However, unlike a virtual machine, that has its own kernel, all Docker containers share the host kernel. So, all system calls being made by a Docker Container would be made to the host kernel. This gives a performance advantage to Containers over Virtual Machines~\cite{kyoung2014}.

Docker Hub~\cite{dockerhub} and Docker Store are central repositories that maintain several official and community Docker images. Using these repositories, a Docker user can maintain her Docker image and use it on any host by simply pulling the image from Docker Hub onto the host machine. Docker Hub is a very popular Docker image sharing website with about 400 thousand public images available[23]. 
\subsection{Seccomp}
Seccomp~\cite{seccomplinux} is a feature in Linux kernel that makes process to make a one-way transit to a “Secure Computing Mode” where it is only allowed to make certain system calls (read(), write(), exit(), sigreturn()) on already open file descriptors. This is done to restrict untrusted processes to limited functionality. Seccomp-bpf~\cite{seccomplinux} was developed as an extension to Seccomp that could be used with a configurable policy to filter system calls using Berkeley packet filter~\cite{bpf1993} rules.

Since Docker containers make system calls to the kernel, Docker 1.10 was released with custom Seccomp profile support. By defining a list of system calls that are allowed/disallowed, the attack surface of the host kernel is decreased. The Seccomp profile is attached to a running Docker container when the container is started. The system calls made by the container are then filtered using a mechanism similar to Berkeley filter packets according to the rules defined in the seccomp policy. With this new feature, a default Seccomp policy was also introduced which is applied to each Docker container by default. This Seccomp policy blocks 44 “vulnerable” system calls and allows about 300 system calls~\cite{defaultseccomp}.
\subsection{Motivation}
Seccomp support was added as a mechanism to Docker to limit the system calls that could be made by a Docker container. However, a policy is required to define which system calls should be allowed or blocked. While there is a default policy available, it doesn’t provide least-privilege and exposes a larger attack surface. Since every image contains different executable code and has different requirements, we hypothesize that an image-specific profile could be generated that could provide a lesser-privilege to the container running the image by only allowing the system calls that are required and blocking the rest.  
We had several decisions to make before going about implementing DockerGate. We decided to perform small experiments before going ahead with the actual development of the prototype.
\subsubsection{Dynamic Analysis or Static Analysis ?}
The first decision to take was to decide whether dynamic analysis or static analysis would be well suited for this solution. While dynamic analysis by logging all system calls made to the kernel would have been easier to implement, triggering all the executable code for every separate image would have been an almost unfeasible task. We still decided to experiment with a tool called strace~\cite{strace} to figure out what system calls were required\\

We conducted a very naive experiment to determine the system calls used by a container. We used the strace utility in Linux to trace the system calls used by a container. We experimented with the hello-world image of docker and 'straced' the docker container for the image.

In this experiment, the strace identified 32 unique system calls for running this container. To verify that these 32 system calls were sufficient to successfully spawn the container, with default deny policy and allowing only 32 system calls identified we attempted to create and run a container, but it would fail to run. So, we decided to define Seccomp policy which would contain the 32 system calls and all the rest of 304 system calls. We followed an iterative approach where we would remove a system call and check if the container would run successfully. If container failed, we considered that system call as required system call for running a containers. If container ran successfully, we removed the system call from the list. With this iterative approach we shortlisted a total of 88 system calls.

Thus, concluding that strace utility is not capable of capturing all the system calls, we decided in performing static analysis on the docker image would provide better results as it would be all-inclusive of the executable code in the image.

\subsubsection{Files to Analyze}

We then proceeded to implement a proof-of-concept prototype for DockerGate. Because of the limitation of time, we decided to focus only on executable binaries that were present inside the image. This decision was supported by an initial analysis of the file composition of a random sample of 100 Docker images. It was found that Docker Images generally contain very little Source code and are mostly comprised of executable binaries in the form of ELF executables or JAR executable files. We decided to focus on ELF-executable files as they were the more prevalent types of files in the random sample.

\subsection{Threat Model}
We consider that an attacker has gained complete control of a docker container using a vulnerability present in the application being run inside the container. The attacker’s goal is to impede the functioning of the host operating system or the kernel by calling a set of vulnerable system calls that are not required by the application being run by the container but might be allowed by the default policy. We do not consider the possibility that the vulnerable system calls could be required by the application itself. The Seccomp policy generated should be able to block the other system calls.